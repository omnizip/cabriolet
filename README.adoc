image:https://img.shields.io/gem/v/cabriolet.svg[RubyGems Version, link=https://rubygems.org/gems/cabriolet]
image:https://img.shields.io/github/license/omnizip/cabriolet.svg[License]

Pure Ruby implementation for extracting and creating Microsoft compression
format files.

== Introduction

Cabriolet extracts and creates Microsoft Cabinet (.CAB) files and related
compression formats using pure Ruby.

This gem fully covers the features of libmspack and cabextract, implementing all
Microsoft compression formats for both extraction (decompression) and creation
(compression).

NOTE: No C extensions required, works on any platform where Ruby runs.

== Supported Formats

Cabriolet provides complete bidirectional support (compression and decompression) for seven Microsoft compression formats:

**CAB (Microsoft Cabinet)**::
Microsoft Cabinet files (.CAB) are archive files used extensively in Windows software distribution, updates, and installations. They support multiple compression algorithms (None, LZSS, MSZIP, LZX, Quantum), multi-part spanning, and can store multiple files with full metadata preservation including timestamps and attributes. Cabriolet provides complete CAB support including multi-part cabinet sets, embedded cabinet search, and salvage mode for corrupted files.

**CHM (Compiled HTML Help)**::
Compiled HTML Help files (.CHM) are Microsoft's compressed help file format used in Windows applications since Windows 98. CHM files use an internal file system to store HTML pages, images, stylesheets, and a full-text search index, all compressed with LZX. Cabriolet can extract CHM contents to recreate the original HTML documentation, and create new CHM files from HTML sources with proper compression and indexing.

**SZDD (Single-File LZSS)**::
SZDD is Microsoft's single-file compression format used primarily in Windows installation media and DOS utilities. Files compressed with SZDD typically have the last character of their extension replaced with an underscore (e.g., .TX_ for .TXT). SZDD uses LZSS MODE_EXPAND compression with a 4KB sliding window. Cabriolet supports both normal SZDD format and the QBasic variant, with automatic filename reconstruction during extraction.

**KWAJ (Installation File)**::
KWAJ format (.KWJ) is used in Microsoft installation packages to compress individual files. It supports multiple compression methods including uncompressed storage, XOR encryption (0xFF), SZDD (LZSS), and MSZIP. KWAJ files can embed the original filename and uncompressed size in the header. Cabriolet provides full KWAJ support for all compression methods and can preserve or reconstruct original filenames.

**DOS Help (QuickHelp)**::
QuickHelp (.HLP) is the DOS-based help file format used in Microsoft development tools like QuickC, QuickBASIC, and early Visual C++. Identified by the signature 0x4C 0x4E ("LN"), QuickHelp files contain help topics compressed with optional Huffman coding and LZSS MODE_MSHELP compression. Topics are organized with context strings for navigation. Cabriolet fully supports creating and extracting QuickHelp files with all compression options.

**Windows Help (WinHelp)**::
Windows Help (.HLP) is the help file format used in Windows 3.x through Windows XP, distinct from DOS Help/QuickHelp. WinHelp files are identified by magic numbers 0x35F3 (version 3.x) or 0x3F5F (version 4.x) and use an internal file system containing |SYSTEM (metadata), |TOPIC (compressed help text), and optionally B-tree indexes. Topics are compressed with Zeck LZ77, a custom LZ77 variant with 4KB sliding window and variable-length matches (3-271 bytes). Cabriolet provides complete support for both WinHelp 3.x and 4.x formats with bidirectional Zeck LZ77 compression.

**LIT (Microsoft Reader eBooks)**::
LIT is Microsoft's proprietary eBook format for the Microsoft Reader application. LIT files use a complex internal structure with directory systems (IFCM/AOLL), manifest with content type mappings, and NameList with UTF-16LE encoding. Content is typically compressed with LZX. Cabriolet supports reading and creating non-encrypted LIT files; DRM-protected (DES-encrypted) LIT files are intentionally not supported as DRM circumvention is not a goal of this project.

**OAB (Offline Address Book)**::
Offline Address Book files (.OAB) are used by Microsoft Outlook and Exchange Server to provide offline access to address book data. OAB files are compressed with LZX and support incremental updates through patch files that contain only changes from a base version. Cabriolet can extract full OAB files, apply incremental patches, create new OAB files, and generate incremental patches between versions.


=== Features

* **Full format support** for all 7 Microsoft compression formats
** CAB (Microsoft Cabinet)
** CHM (Compiled HTML Help)
** SZDD (Single-file LZSS compression)
** KWAJ (Installation file compression)
** HLP (Windows Help)
** LIT (Microsoft Reader eBooks)
** OAB (Offline Address Book)

* **Bidirectional operations** (compress and decompress)
* **All compression algorithms**
** None (uncompressed storage)
** LZSS (4KB sliding window, 3 modes)
** MSZIP (DEFLATE/RFC 1951)
** LZX (advanced with Intel E8 preprocessing)
** Quantum (adaptive arithmetic coding)

* **Advanced features**
** Multi-part cabinet sets (spanning, merging)
** Embedded cabinet search
** Salvage mode for corrupted files
** Custom I/O handlers
** Progress callbacks
** Checksum verification
** Metadata preservation (timestamps, attributes)

* **Pure Ruby** - No compilation needed, works everywhere
* **Comprehensive testing** - 1,273 test examples, 0 failures
* **Complete CLI** - 30+ commands for all operations

=== Architecture

.High-level architecture
[source]
----
Application Layer (CLI/API)
         ↓
  Format Layer (CAB, CHM, SZDD, KWAJ, HLP, LIT, OAB)
         ↓
  Algorithm Layer (None, LZSS, MSZIP, LZX, Quantum)
         ↓
  Binary I/O Layer (BinData structures, Bitstreams)
         ↓
  System Layer (I/O abstraction, file/memory handles)
----

For complete architecture, see link:ARCHITECTURE.md[Architecture Documentation].

== Installation

Add to your Gemfile:

[source,ruby]
----
gem "cabriolet"
----

Or install directly:

[source,shell]
----
gem install cabriolet
----

For detailed installation instructions, see
link:docs/getting-started/installation.adoc[Installation Guide].

== System requirements

* Ruby 2.7 or higher
* Operating Systems: Linux, macOS, Windows
* Dependencies: bindata (~> 2.5), thor (~> 1.3)

== Usage

=== Command line interface

==== CAB (Cabinet) operations

===== List contents

[source,shell]
----
cabriolet list example.cab
----

.Example output
[example]
====
[source]
----
Cabinet: example.cab (Set ID: 12345, Index: 0)
Folders: 1, Files: 2
Files:
  README.txt (1,234 bytes)
  data.bin (45,678 bytes)
----
====

===== Extract all files

[source,shell]
----
cabriolet extract example.cab
----

===== Extract to specific directory

[source,shell]
----
cabriolet extract example.cab --output /path/to/output
----

===== Test cabinet integrity

[source,shell]
----
cabriolet test example.cab
----

===== Show detailed information

[source,shell]
----
cabriolet info example.cab
----

.Example output
[example]
====
[source]
----
Cabinet Information
==================================================
Filename: example.cab
Set ID: 12345
Set Index: 0
Size: 100,000 bytes
Folders: 2
Files: 15

Folders:
  [0] MSZIP (5 blocks)
  [1] LZX (3 blocks)

Files:
  README.txt
    Size: 1,234 bytes
    Modified: 2024-01-15 10:30:00
    Attributes: archive
  ...
----
====

===== Search for embedded CABs

[source,shell]
----
cabriolet search installer.exe --verbose
----

.Example output
[example]
====
[source]
----
Cabinet found at offset 1024
  Files: 50, Folders: 1
Cabinet found at offset 524288
  Files: 20, Folders: 1

Total: 2 cabinet(s) found
----
====

===== Create CAB file

[source,shell]
----
cabriolet create output.cab file1.txt file2.txt
cabriolet create output.cab *.txt --compression mszip
cabriolet create output.cab files/ --compression lzx
----

**Compression options**:

* `none` - Uncompressed storage
* `lzss` - LZSS compression (default for small files)
* `mszip` - MSZIP/DEFLATE compression (recommended)
* `lzx` - LZX compression (best ratio, slower)
* `quantum` - Quantum compression (experimental)

==== CHM (HTML Help) operations

===== List CHM contents

[source,shell]
----
cabriolet chm-list help.chm
----

===== Extract CHM files

[source,shell]
----
cabriolet chm-extract help.chm output/
----

===== Show CHM information

[source,shell]
----
cabriolet chm-info help.chm
----

===== Create CHM file

[source,shell]
----
cabriolet chm-create help.chm index.html page1.html page2.html
cabriolet chm-create help.chm docs/*.html --window-bits 16
----

**Options**:

* `--window-bits` - LZX window size (15-21, default: 16)
* `--verbose` - Enable verbose output

==== SZDD operations

===== Expand SZDD file

[source,shell]
----
cabriolet expand file.tx_
cabriolet expand file.tx_ output.txt
----

===== Compress to SZDD

[source,shell]
----
cabriolet compress file.txt
cabriolet compress file.txt --missing-char t
cabriolet compress file.txt --format qbasic
----

**Options**:

* `--missing-char` - Last character of original filename
* `--format` - Format type (`normal` or `qbasic`)

===== Show SZDD information

[source,shell]
----
cabriolet szdd-info file.tx_
----

==== KWAJ operations

===== Extract KWAJ file

[source,shell]
----
cabriolet kwaj-extract setup.kwj
cabriolet kwaj-extract setup.kwj output.exe
----

===== Compress to KWAJ

[source,shell]
----
cabriolet kwaj-compress file.exe
cabriolet kwaj-compress file.exe --compression szdd --include-length
cabriolet kwaj-compress file.exe --filename original.exe
----

**Compression options**:

* `none` - Uncompressed
* `xor` - XOR encryption (0xFF)
* `szdd` - LZSS compression (default)
* `mszip` - MSZIP compression

**Other options**:

* `--include-length` - Include uncompressed length in header
* `--filename` - Embed original filename

===== Show KWAJ information

[source,shell]
----
cabriolet kwaj-info setup.kwj
----

==== HLP (Windows Help) operations

Cabriolet supports both HLP format variants:

* **QuickHelp** - DOS-based format (0x4C 0x4E signature)
* **Windows Help** - Windows 3.x/4.x format (0x35F3/0x3F5F signatures)

===== Extract HLP file (auto-detects format)

[source,shell]
----
cabriolet hlp-extract help.hlp output/
----

===== Create QuickHelp file

[source,shell]
----
cabriolet hlp-create output.hlp topic1.txt topic2.txt
----

===== Create Windows Help file (3.x or 4.x)

[source,shell]
----
cabriolet hlp-create output.hlp topic1.txt topic2.txt --format winhelp3
cabriolet hlp-create output.hlp topic1.txt topic2.txt --format winhelp4
----

===== Show HLP information

[source,shell]
----
cabriolet hlp-info help.hlp
----

==== LIT (eBook) operations

===== Extract LIT file

[source,shell]
----
cabriolet lit-extract book.lit output/
----

NOTE: DES-encrypted (DRM-protected) LIT files are not supported. For encrypted
files, use Microsoft Reader or convert to another format first.

===== Create LIT file

[source,shell]
----
cabriolet lit-create book.lit chapter1.html chapter2.html
----

===== Show LIT information

[source,shell]
----
cabriolet lit-info book.lit
----

==== OAB (Address Book) operations

===== Extract OAB file

[source,shell]
----
cabriolet oab-extract contacts.lzx output.oab
cabriolet oab-extract patch.lzx output.oab --base contacts.oab
----

**Options**:

* `--base` - Base file for incremental patch application

===== Create OAB file

[source,shell]
----
cabriolet oab-create contacts.oab output.lzx
cabriolet oab-create new.oab patch.lzx --base old.oab
----

**Options**:

* `--base` - Create incremental patch
* `--block-size` - LZX block size (default: 32768)

===== Show OAB information

[source,shell]
----
cabriolet oab-info contacts.lzx
----

==== Global Options

All commands support:

* `--verbose, -v` - Enable verbose output
* `--help, -h` - Show command help

=== Ruby API

==== CAB operations

===== Basic extraction

[source,ruby]
----
require "cabriolet"

# Open and extract
decompressor = Cabriolet::CAB::Decompressor.new
cabinet = decompressor.open("example.cab")

# List files
cabinet.files.each do |file|
  puts "#{file.filename}: #{file.length} bytes"
end

# Extract single file
file = cabinet.files.first
decompressor.extract_file(file, "output.txt")

# Extract all files
decompressor.extract_all(cabinet, "output/")
----

===== Advanced extraction options

[source,ruby]
----
decompressor = Cabriolet::CAB::Decompressor.new
decompressor.salvage = true  # Enable salvage mode
decompressor.fix_mszip = true  # Enable MSZIP error recovery
decompressor.buffer_size = 8192  # Set buffer size

cabinet = decompressor.open("example.cab")
decompressor.extract_all(cabinet, "output/")
----

===== Multi-part cabinets

[source,ruby]
----
decompressor = Cabriolet::CAB::Decompressor.new

# Open first cabinet
cab1 = decompressor.open("disk1.cab")

# Open and append subsequent parts
cab2 = decompressor.open("disk2.cab")
decompressor.append(cab1, cab2)

cab3 = decompressor.open("disk3.cab")
decompressor.append(cab2, cab3)

# Extract from merged cabinet set
decompressor.extract_all(cab1, "output/")
----

===== Search for embedded cabinets

[source,ruby]
----
decompressor = Cabriolet::CAB::Decompressor.new
cabinet = decompressor.search("installer.exe")

while cabinet
  puts "Cabinet at offset #{cabinet.base_offset}"
  puts "  Files: #{cabinet.file_count}"

  # Extract this cabinet
  decompressor.extract_all(cabinet, "output_#{cabinet.base_offset}/")

  # Move to next found cabinet
  cabinet = cabinet.next
end
----

===== Create CAB file

[source,ruby]
----
compressor = Cabriolet::CAB::Compressor.new

# Add files
compressor.add_file("README.txt")
compressor.add_file("data.bin", "custom/path.bin")

# Generate cabinet
bytes = compressor.generate("output.cab",
  compression: :mszip,
  set_id: 12345,
  cabinet_index: 0)

puts "Created output.cab (#{bytes} bytes)"
----

**Compression options**:

* `:none` - No compression
* `:lzss` - LZSS compression
* `:mszip` - MSZIP/DEFLATE compression (recommended)
* `:lzx` - LZX compression (best ratio)
* `:quantum` - Quantum compression (experimental)

==== CHM operations

===== Extract CHM files

[source,ruby]
----
decompressor = Cabriolet::CHM::Decompressor.new
chm = decompressor.open("help.chm")

# List files
chm.files&.each do |file|
  puts file.filename
end

# Extract single file
file = chm.files.first
decompressor.extract(file, "output.html") if file

# Extract all files
chm.files&.each do |file|
  output_path = File.join("output", file.filename)
  FileUtils.mkdir_p(File.dirname(output_path))
  decompressor.extract(file, output_path)
end
----

===== Fast CHM parsing

[source,ruby]
----
decompressor = Cabriolet::CHM::Decompressor.new

# Quick open (headers only, no file enumeration)
chm = decompressor.fast_open("help.chm")

# Find specific file quickly
file = Models::CHMFile.new
result = decompressor.fast_find(chm, "/index.html", file)

if file.length > 0
  decompressor.extract(file, "index.html")
end
----

===== Create CHM file

[source,ruby]
----
compressor = Cabriolet::CHM::Compressor.new

# Add files
compressor.add_file("index.html", "/index.html", section: :compressed)
compressor.add_file("image.png", "/images/image.png", section: :uncompressed)

# Generate CHM
bytes = compressor.generate("help.chm",
  window_bits: 16,
  language_id: 0x0409)

puts "Created help.chm (#{bytes} bytes)"
----

**Options**:

* `window_bits` - LZX window size (15-21, default: 16)
* `language_id` - Language identifier (default: 0x0409 for English US)
* `timestamp` - Custom timestamp (default: current time)

==== SZDD operations

===== Expand SZDD file

[source,ruby]
----
decompressor = Cabriolet::SZDD::Decompressor.new

# Open and get header
header = decompressor.open("file.tx_")

puts "Format: #{header.format_name}"
puts "Length: #{header.length} bytes"
puts "Missing char: #{header.missing_char}" if header.missing_char

# Extract
decompressor.extract(header, "file.txt")

# Or one-shot
decompressor.decompress("file.tx_", "file.txt")
----

===== Compress to SZDD

[source,ruby]
----
compressor = Cabriolet::SZDD::Compressor.new

# Compress file
bytes = compressor.compress("file.txt", "file.tx_",
  missing_char: "t",
  format: :normal)

# Or compress data from memory
bytes = compressor.compress_data("Hello, world!", "output.tx_")
----

**Format options**:

* `:normal` - Standard SZDD format (MS-DOS compatible)
* `:qbasic` - QBasic SZDD format

==== KWAJ operations

===== Extract KWAJ file

[source,ruby]
----
decompressor = Cabriolet::KWAJ::Decompressor.new

# Open and get header
header = decompressor.open("setup.kwj")

puts "Compression: #{header.compression_name}"
puts "Length: #{header.length} bytes" if header.length
puts "Filename: #{header.filename}" if header.filename

# Extract
decompressor.extract(header, "setup.kwj", "output.exe")

# Or one-shot
decompressor.decompress("setup.kwj", "setup.exe")
----

===== Compress to KWAJ

[source,ruby]
----
compressor = Cabriolet::KWAJ::Compressor.new

# Compress file
bytes = compressor.compress("file.exe", "file.kwj",
  compression: :szdd,
  include_length: true,
  filename: "original.exe")

# Compression options: :none, :xor, :szdd, :mszip
----

==== HLP (Windows Help) operations

===== Extract HLP file (auto-detects format)

[source,ruby]
----
# Works with both QuickHelp and Windows Help formats
decompressor = Cabriolet::HLP::Decompressor.new
header = decompressor.open("help.hlp")

# Format is automatically detected
case header
when Cabriolet::Models::HLPHeader
  puts "QuickHelp format (DOS)"
when Cabriolet::Models::WinHelpHeader
  puts "Windows Help format (#{header.version_string})"
end

# Extract files
decompressor.extract_all(header, "output/")
----

===== Create QuickHelp file

[source,ruby]
----
compressor = Cabriolet::HLP::Compressor.new

# Add topics
compressor.add_data("Topic 1 text", "topic1")
compressor.add_data("Topic 2 text", "topic2")

# Generate QuickHelp format (DOS)
bytes = compressor.generate("help.hlp",
  database_name: "MyHelp",
  control_character: 0x3A)  # ':'
----

===== Create Windows Help file

[source,ruby]
----
# Create WinHelp 3.x format file
compressor = Cabriolet::HLP::WinHelp::Compressor.new

# Add system metadata
compressor.add_system_file(
  title: "My Help File",
  copyright: "Copyright 2025",
  contents: "contents.hlp")

# Add topics (automatically compressed with Zeck LZ77)
compressor.add_topic_file(["Topic 1 text", "Topic 2 text"], compress: true)

# Generate WinHelp 3.x or 4.x
bytes = compressor.generate("help.hlp", version: :winhelp3)
# or version: :winhelp4 for WinHelp 4.x format
----

===== Extract Windows Help internal files

[source,ruby]
----
decompressor = Cabriolet::HLP::WinHelp::Decompressor.new("help.hlp")
header = decompressor.parse

# List internal files (|SYSTEM, |TOPIC, etc.)
puts decompressor.internal_filenames

# Extract specific internal file
system_data = decompressor.extract_system_file
topic_data = decompressor.extract_topic_file

# Decompress topics
if topic_data
  decompressed = decompressor.decompress_topic(topic_data, expected_size)
end
----

NOTE: Windows Help format has limited public documentation. Implementation is based on reverse engineering and the helpdeco project.

==== LIT (eBook) operations

===== Extract LIT file

[source,ruby]
----
decompressor = Cabriolet::LIT::Decompressor.new

begin
  lit = decompressor.open("book.lit")

  if lit.encrypted
    raise "LIT file is DRM-encrypted. Decryption not supported."
  end

  # Extract files
  lit.files.each do |file|
    decompressor.extract_file(file, "output/#{file.filename}")
  end
rescue NotImplementedError => e
  puts "Error: #{e.message}"
end
----

===== Create LIT file

[source,ruby]
----
compressor = Cabriolet::LIT::Compressor.new

compressor.add_file("content.html", "/content.html")
bytes = compressor.generate("book.lit")
----

**Limitations**:

* DES encryption (DRM) is intentionally not supported
* For encrypted LIT files, decrypt with Microsoft Reader first

==== OAB (Offline Address Book) operations

===== Extract OAB file

[source,ruby]
----
decompressor = Cabriolet::OAB::Decompressor.new

# Extract full file
decompressor.decompress("contacts.lzx", "contacts.oab")

# Apply incremental patch
decompressor.decompress_incremental("patch.lzx", "base.oab", "new.oab")
----

===== Create OAB file

[source,ruby]
----
compressor = Cabriolet::OAB::Compressor.new

# Compress full file
compressor.compress("contacts.oab", "contacts.lzx")

# Create incremental patch
compressor.compress_incremental("new.oab", "old.oab", "patch.lzx")
----

=== Custom I/O Handlers

==== In-memory operations

[source,ruby]
----
# Create custom I/O system
memory_io = Cabriolet::System::IOSystem.new

# Process entirely in memory
decompressor = Cabriolet::CAB::Decompressor.new(memory_io)

# Load CAB data
cab_data = File.binread("example.cab")
input = Cabriolet::System::MemoryHandle.new(cab_data)
cabinet = decompressor.parser.parse_handle(input, "example.cab")

# Extract to memory
file = cabinet.files.first
output = Cabriolet::System::MemoryHandle.new("", Cabriolet::Constants::MODE_WRITE)
# ... extract to memory handle
----

==== Custom I/O system

[source,ruby]
----
class CustomIOSystem < Cabriolet::System::IOSystem
  def open(filename, mode)
    # Custom open logic
  end

  def read(handle, bytes)
    # Custom read logic
  end

  # ... implement other methods
end

# Use custom I/O
custom_io = CustomIOSystem.new
decompressor = Cabriolet::CAB::Decompressor.new(custom_io)
----

=== Custom Algorithm Registration

Cabriolet allows you to register custom compression/decompression algorithms with the [`AlgorithmFactory`](lib/cabriolet/algorithm_factory.rb:1). This enables:

* **Custom implementations** of standard algorithms for optimization
* **Experimental algorithms** for research and development
* **Format-specific variations** of compression algorithms
* **Testing environments** with isolated algorithm sets

==== Registering a Custom Algorithm

[source,ruby]
----
# Define your custom algorithm (must inherit from Base)
class MyOptimizedLZX < Cabriolet::Decompressors::Base
  def decompress(input_size, output_size)
    # Your optimized implementation
    data = @input.read(input_size)
    # ... custom decompression logic
    @output.write(decompressed_data)
    output_size
  end
end

# Register globally
Cabriolet.algorithm_factory.register(
  :optimized_lzx,
  MyOptimizedLZX,
  category: :decompressor,
  priority: 10  # Higher priority = preferred over built-ins
)

# Use in extraction (automatically uses your custom algorithm)
decompressor = Cabriolet::CAB::Decompressor.new("archive.cab")
# When extracting LZX folders, your algorithm will be used
----

==== Per-Instance Custom Factory

For isolated testing or experimentation without affecting global state:

[source,ruby]
----
# Create custom factory without built-in algorithms
custom_factory = Cabriolet::AlgorithmFactory.new(auto_register: false)

# Register only your algorithms
custom_factory.register(:my_algo, MyAlgorithm, category: :decompressor)

# Create decompressor instances with custom factory
# (Note: Not all format handlers currently support custom factories)
decompressor = Cabriolet::CAB::Decompressor.new
# Custom factory usage would be implemented by format handlers
----

==== Replacing Built-in Algorithms

You can replace built-in algorithms with optimized versions:

[source,ruby]
----
# Unregister the built-in
Cabriolet.algorithm_factory.unregister(:lzss, :decompressor)

# Register your optimized version
Cabriolet.algorithm_factory.register(
  :lzss,
  MyOptimizedLZSS,
  category: :decompressor,
  priority: 10
)

# All future LZSS decompression will use your implementation
----

==== Format-Specific Algorithms

Register algorithms that only apply to specific formats:

[source,ruby]
----
# Register CAB-specific LZX variant
Cabriolet.algorithm_factory.register(
  :cab_lzx,
  CABOptimizedLZX,
  category: :decompressor,
  format: :cab  # Only used for CAB files
)

# Register CHM-specific variant
Cabriolet.algorithm_factory.register(
  :chm_lzx,
  CHMOptimizedLZX,
  category: :decompressor,
  format: :chm  # Only used for CHM files
)
----

==== Algorithm Requirements

Custom algorithms must:

* **Inherit from the appropriate base class**:
** `Cabriolet::Compressors::Base` for compressors
** `Cabriolet::Decompressors::Base` for decompressors

* **Implement required methods**:
** Decompressors: `decompress(input_size, output_size)`
** Compressors: `compress()`

* **Use provided instance variables**:
** `@input` - Input handle (read operations)
** `@output` - Output handle (write operations)
** `@io_system` - I/O system for operations
** `@buffer_size` - Buffer size for operations

**Example custom decompressor**:

[source,ruby]
----
class CustomAlgorithm < Cabriolet::Decompressors::Base
  def decompress(input_size, output_size)
    # Read compressed data
    compressed = @input.read(input_size)

    # Your decompression logic
    decompressed = my_decompress_logic(compressed)

    # Write decompressed data
    @output.write(decompressed)

    # Return bytes written
    decompressed.bytesize
  end

  private

  def my_decompress_logic(data)
    # Custom decompression implementation
  end
end
----

**Example custom compressor**:

[source,ruby]
----
class CustomCompressor < Cabriolet::Compressors::Base
  def compress
    # Read uncompressed data
    data = @input.read

    # Your compression logic
    compressed = my_compress_logic(data)

    # Write compressed data
    @output.write(compressed)

    # Return bytes written
    compressed.bytesize
  end

  private

  def my_compress_logic(data)
    # Custom compression implementation
  end
end
----

==== Use Cases

**Performance optimization**::
Replace built-in algorithms with platform-optimized versions (e.g., using native extensions for specific platforms)

**Research and development**::
Test experimental compression algorithms without modifying the core library

**Format variations**::
Implement format-specific optimizations or variations of standard algorithms

**Testing**::
Create isolated test environments with mock or simplified algorithms

== Plugin Architecture

Cabriolet supports a powerful plugin system that enables easy distribution and loading of extensions.

=== Installing Plugins

Plugins are distributed as Ruby gems with the naming pattern `cabriolet-plugin-*`:

[source,bash]
----
gem install cabriolet-plugin-bzip2
----

=== Loading Plugins

Plugins are automatically discovered from installed gems:

[source,ruby]
----
require 'cabriolet'

# Discover all installed plugins
Cabriolet.plugin_manager.discover_plugins

# Load and activate a specific plugin
Cabriolet.plugin_manager.load_plugin('bzip2')
Cabriolet.plugin_manager.activate_plugin('bzip2')

# Or auto-activate all plugins
Cabriolet.plugin_manager.auto_activate_plugins
----

=== Listing Plugins

[source,ruby]
----
# List all plugins
plugins = Cabriolet.plugin_manager.list_plugins

# List only active plugins
active = Cabriolet.plugin_manager.list_plugins(state: :active)

# Check if a plugin is active
if Cabriolet.plugin_manager.plugin_active?('bzip2')
  puts "BZip2 plugin is active"
end
----

=== Creating Plugins

To create your own plugin, see the example plugins:

- `examples/plugins/cabriolet-plugin-example/` - Simple ROT13 example
- `examples/plugins/cabriolet-plugin-bzip2/` - Advanced BZip2 example

Basic plugin structure:

[source,ruby]
----
class MyPlugin < Cabriolet::Plugin
  def metadata
    {
      name: "my-plugin",
      version: "1.0.0",
      author: "Your Name",
      description: "My custom compression algorithm",
      cabriolet_version: "~> 0.1"
    }
  end

  def setup
    # Register your algorithms
    register_algorithm(:my_algo, MyCompressor, category: :compressor)
    register_algorithm(:my_algo, MyDecompressor, category: :decompressor)
  end
end
----

=== Plugin Configuration

Configure plugins via `~/.cabriolet/plugins.yml`:

[source,yaml]
----
discovery:
  auto_discover: true
  auto_load: true
  auto_activate: true

plugins:
  bzip2:
    enabled: true
    config:
      compression_level: 9
----

=== Plugin Safety

All plugins are validated before loading:

- ✓ Inheritance validation
- ✓ Metadata validation
- ✓ Version compatibility checking
- ✓ Dependency resolution
- ✓ Safety scanning

Failed plugins are isolated and don't affect Cabriolet or other plugins.

=== Error Handling

==== Common errors

[source,ruby]
----
begin
  decompressor = Cabriolet::CAB::Decompressor.new
  cabinet = decompressor.open("example.cab")
  decompressor.extract_all(cabinet, "output/")
rescue Cabriolet::IOError => e
  puts "I/O error: #{e.message}"
rescue Cabriolet::ParseError => e
  puts "Parse error: #{e.message}"
rescue Cabriolet::ChecksumError => e
  puts "Checksum failed: #{e.message}"
rescue Cabriolet::DecompressionError => e
  puts "Decompression error: #{e.message}"
rescue Cabriolet::Error => e
  puts "General error: #{e.message}"
end
----

==== Salvage mode for corrupted files

[source,ruby]
----
decompressor = Cabriolet::CAB::Decompressor.new
decompressor.salvage = true  # Enable error recovery

# Will skip bad files and continue
cabinet = decompressor.open("corrupted.cab")
decompressor.extract_all(cabinet, "output/")
----

==== Fix MSZIP errors

[source,ruby]
----
decompressor = Cabriolet::CAB::Decompressor.new
decompressor.fix_mszip = true  # Ignore MSZIP checksums, recover from errors

cabinet = decompressor.open("example.cab")
decompressor.extract_all(cabinet, "output/")
----

=== API Reference

==== Cabriolet::CAB::Decompressor

Main class for CAB file operations.

===== Class methods

`new(io_system = nil)`::
Creates a new decompressor instance.
+
Parameters:::
`io_system`::: Optional custom I/O system implementation
+
Returns:::
`Cabriolet::CAB::Decompressor`::: New decompressor instance

===== Instance methods

`open(filename)`::
Opens and parses a CAB file.
+
Parameters:::
`filename`::: Path to CAB file
+
Returns:::
`Cabriolet::Models::Cabinet`::: Parsed cabinet object
+
Raises:::
`Cabriolet::ParseError`::: If file is not valid CAB format
`Cabriolet::IOError`::: If file cannot be opened

`extract_file(file, output_path, **options)`::
Extracts a single file from the cabinet.
+
Parameters:::
`file`::: `Cabriolet::Models::File` object
`output_path`::: Where to write the file
`options`::: Optional hash (salvage, overwrite, etc.)
+
Returns:::
`Integer`::: Number of bytes extracted

`extract_all(cabinet, output_dir, **options)`::
Extracts all files from the cabinet.
+
Parameters:::
`cabinet`::: `Cabriolet::Models::Cabinet` object
`output_dir`::: Directory to extract to
`options`::: Optional hash
+
Returns:::
`Integer`::: Number of files extracted

`search(filename)`::
Searches for embedded cabinets in a file.
+
Parameters:::
`filename`::: File to search
+
Returns:::
`Cabriolet::Models::Cabinet`::: First found cabinet (use `.next` for others)
`nil`::: If no cabinets found

`append(cabinet, next_cabinet)`::
Merges two cabinets in a multi-part set.
+
Parameters:::
`cabinet`::: First cabinet
`next_cabinet`::: Next cabinet in sequence
+
Returns:::
`void`

===== Attributes

`buffer_size`::
I/O buffer size in bytes (default: 4096)

`salvage`::
Enable salvage mode for corrupted files (default: false)

`fix_mszip`::
Enable MSZIP error recovery (default: false)

==== Cabriolet::CAB::Compressor

Class for creating CAB files.

===== Instance methods

`add_file(source_path, cab_path = nil)`::
Adds a file to the cabinet.
+
Parameters:::
`source_path`::: Path to source file
`cab_path`::: Path within cabinet (optional, defaults to basename)

`generate(output_file, **options)`::
Generates the cabinet file.
+
Parameters:::
`output_file`::: Path to output CAB file
`options`::: Hash with compression, set_id, etc.
+
Returns:::
`Integer`::: Bytes written

**Example**:
[source,ruby]
----
compressor = Cabriolet::CAB::Compressor.new
compressor.add_file("file1.txt")
compressor.add_file("file2.txt")
bytes = compressor.generate("output.cab", compression: :mszip)
----

==== Compression Algorithm Status

[cols="1,1,1,3"]
|===
| Algorithm | Decompression | Compression | Notes

| **None**
| ✅ Working
| ✅ Working
| Uncompressed storage

| **LZSS**
| ✅ Working
| ✅ Working
| 4KB sliding window, 3 modes (EXPAND, MSHELP, QBASIC)

| **MSZIP**
| ✅ Working
| ✅ Working
| DEFLATE/RFC 1951, fixed Huffman

| **LZX**
| ✅ Working
| ✅ Working
| UNCOMPRESSED blocks, 32KB-2MB window

| **Quantum**
| ✅ Working
| ⚠️ Functional
| Literals + short matches work. Complex patterns pending.
|===

=== Configuration Options

==== Buffer Sizes

[source,ruby]
----
# Set default buffer size globally
Cabriolet.default_buffer_size = 8192

# Or per decompressor
decompressor.buffer_size = 16384
----

==== Verbose Output

[source,ruby]
----
# Enable verbose output globally
Cabriolet.verbose = true

# Or use --verbose flag in CLI
# cabriolet extract file.cab --verbose
----

=== Compression Algorithm Selection Guide

[cols="1,1,1,1,3"]
|===
| Algorithm | Ratio | Speed | Complexity | Use Case

| **None**
| 1:1
| Fastest
| Trivial
| Already compressed data, testing

| **LZSS**
| 2-3:1
| Fast
| Low
| Small files, compatibility

| **MSZIP**
| 3-5:1
| Medium
| Medium
| **Recommended** for most uses

| **LZX**
| 5-10:1
| Slow
| High
| Large files, best compression

| **Quantum**
| 4-8:1
| Medium
| Very High
| Experimental, use with caution
|===

=== Return values

All methods return appropriate values or raise exceptions:

* **Decompression methods**: Return bytes extracted or raise error
* **Compression methods**: Return bytes written or raise error
* **Parse methods**: Return model objects or raise `ParseError`
* **File operations**: Return file handles or raise `IOError`

== Development

=== Building from source

[source,shell]
----
git clone https://github.com/omnizip/cabriolet.git
cd cabriolet
bundle install
bundle exec rake
----

=== Running tests

[source,shell]
----
bundle exec rspec
----


=== Running RuboCop

[source,shell]
----
bundle exec rubocop
bundle exec rubocop -A  # Auto-correct
----


== Known limitations

For complete details on known issues and workarounds, see link:KNOWN_ISSUES.md[Known Issues].

=== LZX Compression

LZX compression is **production ready** for most use cases:

* ✅ **CHM files**: 100% working, all features
* ✅ **Single-folder CAB**: 100% working
* ✅ **Decompression**: UNCOMPRESSED blocks fully supported
* ✅ **Compression**: UNCOMPRESSED blocks fully supported
* ⚠️ **Multi-folder CAB**: Files at non-zero offsets in second+ folders
** Affects: <5% of CAB files
** Workaround: Use salvage mode or extract folders separately
** Status: Deferred to v0.2.0
* ⚠️ **VERBATIM/ALIGNED blocks**: Compression needs implementation
** Affects: Advanced CHM creation
** Decompression: Working
** Status: Planned for v0.2.0

=== Quantum compression

Quantum compression is **functional but experimental**:

* ✅ **Decompression**: Fully working, production ready
* ✅ **Compression**: Working for:
** Simple literals
** Short matches (3-4 bytes)
** Basic patterns
* ⚠️ **Limitations**:
** Complex repeated patterns may fail
** Very long matches (14+ bytes) have encoding issues
** Recommended: Use LZSS, MSZIP, or LZX instead

=== LIT Format

* DES encryption (DRM) intentionally not supported
* For DRM-protected LIT files, decrypt with Microsoft Reader first

=== HLP/LIT/OAB Formats

* LIT format has no public specification (implementation based on libmspack)
* HLP format supports both QuickHelp (DOS) and Windows Help (3.x/4.x)
** QuickHelp format fully documented, production ready
** Windows Help format based on reverse engineering, production ready
* OAB format has limited documentation (implementation based on libmspack)
* All formats are fully functional for basic operations
* Edge cases for advanced features may exist


== Troubleshooting

=== Extraction failures

Problem:: Invalid CAB signature

Solution:: File may not be a CAB, or is corrupted. Try salvage mode:

[source,shell]
----
cabriolet extract --salvage corrupted.cab
----

Problem:: Checksum mismatch

Solution:: Enable error recovery:

[source,ruby]
----
decompressor.fix_mszip = true
decompressor.salvage = true
----

=== Performance issues

Problem:: Slow extraction

Solution:: Increase buffer size:

[source,ruby]
----
decompressor.buffer_size = 16384
----


== Specifications

* https://en.wikipedia.org/wiki/Cabinet_(file_format)[Microsoft Cabinet File Format - Wikipedia]
* https://www.rfc-editor.org/info/rfc1951[RFC 1951: DEFLATE Compressed Data Format Specification version 1.3, MAY 1996]
* https://learn.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-patch/cc78752a-b4af-4eee-88cb-01f4d8a4c2bf[[MS-PATCH\]: LZX DELTA Compression and Decompression]


== Acknowledgments

A special thank you to Stuart Caie (aka Kyzer) who created the original
libmspack and cabextract projects, and their contributors for:

* Comprehensive CAB format implementation
* Excellent test coverage and test fixtures
* Clear format documentation

Link to the libmspack/cabextract project:
https://www.cabextract.org.uk/libmspack/

Cabriolet is inspired by and builds upon the foundation laid by these projects.

If performance is critical, Cabriolet is not the best choice. Consider using
https://github.com/davispuh/ruby-libmspack[libmspack via FFI] for optimized
speed.


== License

BSD 3-Clause License. See link:LICENSE[LICENSE] file for details.

Some test fixtures are from third-party projects. Test fixtures are **NOT**
distributed with the gem and are only used for development and testing purposes.

These fixtures are sourced from the respective projects and retain their
original licenses:

* Test fixtures in `spec/fixtures/libmspack/` are from the libmspack project
(LGPL 2.1).

* Test fixtures in `spec/fixtures/cabextract/` are from cabextract (GPL 2.0+).

See fixture directories for individual attribution files.
